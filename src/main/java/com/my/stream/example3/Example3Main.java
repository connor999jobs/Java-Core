package com.my.stream.example3;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static java.util.stream.Collectors.groupingBy;

public class Example3Main {
    public static void main(String[] args) {



        Library library = new Library();


        //Получить список всех книг библиотеки, отсортированных по году издания.
        //Для передачи алгоритма сравнения элементов в метод sorted() используется лямбда-выражение
        // Comparator.comparing(Book: :getIssueYear).
        //
        //Оно равносильно анонимному классу в примере выше: означает, что книги сравниваются по году издания.
        //
        //Метод collect(Collectors.toList()) замыкает стрим в список (List).
        //
        //Создавать отдельный метод для сортировки не пришлось. И в целом код выглядит компактнее.
        List list = library.getBooks().stream()
                .sorted(Comparator.comparing(Book::getIssueYear))
                .collect(Collectors.toList());
//        System.out.println(list);


        /*Для преобразования — map()
        Метод используется для преобразования объектов. Это может быть простое извлечение значения одного поля или создание
        объектов другого типа по данным объекта-источника.

        Задача
        Требуется создать список рассылки (объекты типа EmailAddress) из адресов всех читателей библиотеки.
        При этом флаг согласия на рассылку учитывать не будем: библиотека закрывается, так что хотим оповестить всех. */

        List<EmailAddress> addresses = library.getReaders().stream()
                .map(Reader::getEmail)
                .map(EmailAddress::new)
                .collect(Collectors.toList());
//        System.out.println(addresses);
        /* При первом использовании map() получаем из списка читателей список электронных адресов.
        На следующем шаге создаем экземпляры нужного нам класса EmailAddress, а далее собираем полученные адреса
        в список.*/



        /*Для фильтрации — filter()
        Метод фильтрует стрим согласно переданному в метод условию-предикату. Позволяет записать условие в одну строчку
        без громоздких конструкций if-else.

        Задача
        Снова нужно получить список рассылки. Но на этот раз включаем в него только адреса читателей,
        которые согласились на рассылку. Дополнительно нужно проверить, что читатель взял из библиотеки
        больше одной книги. */

        List<EmailAddress> addresses1 = library.getReaders().stream()
                .filter(Reader::isSubscriber)
                .filter(reader -> reader.getBooks().size() > 1)
                .map(Reader::getEmail).map(EmailAddress::new)
                .collect(Collectors.toList());
//        System.out.println(addresses1);
        /*На первом шаге (первое использование filter()) сокращаем число читателей:
        работаем со списком тех, кто дал согласие на рассылку.

        На втором шаге из этого ограниченного числа читателей выбираем тех, кто взял более одной книги.

        Далее уже знакомыми map() и collect() получаем email-адреса, преобразуем их к нужному
        типу и собираем в список. */



        /* Для преобразования и создания линейного списка — flatMap()
        Результат работы flatMap() получается в два действия, на которые намекает само название метода.
        Эти слова и эти операции:

        - map (мы уже знаем, что это преобразование);
        - и flat — дословно «плоский».
        Если применить обычный map() к стриму из списков List<AnyType>, то на выходе получим стрим из списков списков
         — List<List<NewType>>.

        flatMap() позволяет получить «плоский» одномерный список — List<NewType>, в который будут последовательно
        добавлены преобразованные значения из всех списков, полученных после применения map().

        Задача
        Получить список всех книг, взятых читателями. Список не должен содержать дубликатов
        (книг одного автора, с одинаковым названием и годом издания).*/

        List<Book> bookList = library.getReaders().stream()
                .flatMap(reader -> reader.getBooks().stream())
                .distinct()
                .collect(Collectors.toList());
//        System.out.println(bookList);

        /*После применения flatMap() уже получаем стрим, состоящий из всех книг всех читателей,
         а distinct() отвечает за то, чтобы в этом стриме остались только уникальные значения.*/




        /*Для проверки, есть ли хоть что-то подходящее, — anyMatch()
        Простой метод, который принимает на вход условие-предикат и возвращает флаг:

        true, если в стриме есть объект, который удовлетворяет условию;
        false — если такого объекта там нет.
        Задача
        Проверить, взял ли кто-то из читателей библиотеки какие-нибудь книги Оруэлла. */

        boolean match =  library.getReaders().stream()
                .flatMap(reader -> reader.getBooks().stream())
                .anyMatch(book -> "Оруэлл".equals(book.getAuthor()));
//        System.out.println(match);

        /* С помощью flatMap() получаем стрим из всех взятых книг, а anyMatch() определяет, есть ли среди авторов Оруэлл.*/




        /*Чтобы остался только один — reduce()
        Метод reduce() берёт стрим и редуцирует (сокращает) его до одного значения.
        Для этого в метод передаются начальное значение (необязательный параметр) и функция-аккумулятор с двумя параметрами.

        Сначала эта функция применяется к начальному значению и первому элементу стрима,
        затем к полученному на этом шаге результату и следующему элементу стрима — и так до последнего элемента стрима. */

        //Задача
        //Узнать наибольшее число книг, которое сейчас на руках у читателя.
        Integer reduce = library.getReaders().stream()
                .map(reader -> reader.getBooks().size())
                .reduce(0,(max,size) -> size > max ? size : max);
//        System.out.println(reduce);
        /* На первом шаге с помощью map() соотносим с каждым читателем число взятых им книг, а затем с помощью reduce()
        находим максимальный элемент в этом новом стриме.

        Это важно. При каждом вызове функции-аккумулятора создаётся новый объект. Если вы хотите, чтобы
        на выходе reduce() оказался сложный объект — например, коллекция, и ходите в функции-аккумуляторе
        добавлять в неё значения, то на каждом шаге будет создаваться новая коллекция.

        Это плохо сказывается на производительности. В таких случаях лучше использовать collect().*/




        /* Для группировки — collect() + Collectors.groupingBy() и Collectors.mapping()
        Методы groupingBy() и mapping() вовсе не обязательно применять вместе.
        Первый позволяет разбить стрим на группы по заданному признаку. Если эти группы нужны в виде списков,
        то второй метод не понадобится.

        mapping() выручит, если полученные группы нужно хитрым (или не очень) образом преобразовать
        (например, сгруппировать по другим признакам).

        Задача
        Вернёмся к нашим   email-рассылкам. Теперь нужно не просто отправить письма всем, кто согласился
        на рассылку, — будем рассылать разные тексты двум группам:

        тем, у кого взято меньше двух книг, просто расскажем о новинках библиотеки;
        тем, у кого две книги и больше, напомним о том, что их нужно вернуть в срок.*/


        //?????????????????????????????????????????????????????????????????????????????????????????


//        List<String> elist  = new ArrayList<>(Arrays.asList("One","Two","Three","Four","Five","Six","Seven",
//                "Eight","Nine","Ten"));
//
//        Stream stream  = elist.stream();
//        stream.filter(x -> x.toString().length() == 3)
//                .forEach(System.out::println);
//        String[] array = {"Java", "Ruuuuussshhh"};
//        Stream<String> streamOfArray = Arrays.stream(array);
//        streamOfArray.map(s->s.split("")) //Преобразование слова в массив букв
//                .flatMap(Arrays::stream).distinct() //выравнивает каждый сгенерированный поток в один поток
//                .collect(Collectors.toList()).forEach(System.out::println);

//        String[] array = {"Java", "Ruuuuussshhh"};
//        Stream<String> streamOfArray = Arrays.stream(array);
//        streamOfArray.map(s->s.split("")) //Преобразование слова в массив букв
//                .map(Arrays::stream).distinct() //Сделать массив в отдельный поток
//                .collect(Collectors.toList()).forEach(System.out::println);


//        Stream.of(2, 3, 0, 1, 3)
//                .flatMapToInt(x -> IntStream.range(0, x))
//                .forEach(System.out::print);

        int sum = Stream.of(1, 2, 3, 4, 5).reduce(22, (acc, x) -> acc+x);
        System.out.println(sum);
    }

}
